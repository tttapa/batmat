#ifdef __clang__
#pragma clang fp contract(fast)
#endif

#include <batmat/linalg/micro-kernels/gemm.tpp>
#include <bit>

// clang-format off
namespace batmat::linalg::micro_kernels::gemm::@Namespace@_@Negate@ {
constexpr static index_t VL = @VL@;
using DType = @DType@;
using Abi   = datapar::deduced_abi<DType, VL>;
static constexpr bool Negate = @Negate@;
// clang-format on

using enum StorageOrder;
using enum MatrixStructure;

template <StorageOrder O>
using CStorageOrder = std::integral_constant<StorageOrder, O>;
template <MatrixStructure O>
using CMatrixStructure = std::integral_constant<MatrixStructure, O>;

constexpr std::array ColRowMajor{ColMajor, RowMajor};
constexpr std::array Triangular{LowerTriangular, UpperTriangular};

namespace {
template <auto V>
const auto wrap = V;
constexpr index_t get_depth(index_t n) {
    auto un = static_cast<std::make_unsigned_t<index_t>>(n);
    return static_cast<index_t>(std::bit_width(un - 1));
}
constexpr index_t get_depth_or_one(index_t n) { return std::max(index_t{1}, get_depth(n)); }
} // namespace

extern const auto gemm_copy_register_inst_gemm =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, ColRowMajor>(
        []<auto OA, auto OB, auto OC, auto OD>(CStorageOrder<OA>, CStorageOrder<OB>,
                                               CStorageOrder<OC>,
                                               CStorageOrder<OD>) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OD>>;
        });
extern const auto gemm_copy_register_inst_gemm_sA =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, 2>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto S) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate, .shift_A = S ? 1 : -1};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_gemm_sB =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, 2>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto S) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate, .rotate_B = S ? 1 : -1};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_gemm_sC_no_mask =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, 2, get_depth_or_one(VL)>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto Ssign, auto S) -> const void * {
            constexpr int sC = Ssign ? (1 << S) : -(1 << S);
            constexpr KernelConfig Conf{
                .negate = Negate, .rotate_C = sC, .rotate_D = sC, .mask_D = 0};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_gemm_sC_mask =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, 2, get_depth_or_one(VL)>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto Ssign, auto S) -> const void * {
            constexpr int sC = Ssign ? (1 << S) : -(1 << S);
            constexpr KernelConfig Conf{
                .negate = Negate, .rotate_C = sC, .rotate_D = sC, .mask_D = sC};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_trmm_sC =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, 2, 2>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto S, auto M) -> const void * {
            constexpr int sC = S ? 1 : -1;
            constexpr KernelConfig Conf{.negate   = Negate,
                                        .rotate_C = sC,
                                        .rotate_D = sC,
                                        .mask_D   = M ? sC : 0,
                                        .struc_B  = MatrixStructure::LowerTriangular};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_syrk_sC =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, 2, get_depth_or_one(VL), 2>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto Ssign, auto S, auto M) -> const void * {
            constexpr int sC = Ssign ? (1 << S) : -(1 << S);
            constexpr KernelConfig Conf{.negate   = Negate,
                                        .rotate_C = sC,
                                        .rotate_D = sC,
                                        .mask_D   = M ? sC : 0,
                                        .struc_C  = MatrixStructure::LowerTriangular};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_trmm_A =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, Triangular>(
        []<auto OA, auto OB, auto OC, auto SA>(CStorageOrder<OA>, CStorageOrder<OB>,
                                               CStorageOrder<OC>,
                                               CMatrixStructure<SA>) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate, .struc_A = SA};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_trmm_B =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, Triangular>(
        []<auto OA, auto OB, auto OC, auto SB>(CStorageOrder<OA>, CStorageOrder<OB>,
                                               CStorageOrder<OC>,
                                               CMatrixStructure<SB>) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate, .struc_B = SB};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_trtrtr =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, Triangular>(
        []<auto OA, auto OB, auto OC, auto S>(CStorageOrder<OA>, CStorageOrder<OB>,
                                              CStorageOrder<OC>,
                                              CMatrixStructure<S>) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate, .struc_A = S, .struc_B = S, .struc_C = S};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_syrk_C =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, ColRowMajor, Triangular>(
        []<auto OA, auto OB, auto OC, auto OD, auto SC>(CStorageOrder<OA>, CStorageOrder<OB>,
                                                        CStorageOrder<OC>, CStorageOrder<OD>,
                                                        CMatrixStructure<SC>) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate, .struc_C = SC};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OD>>;
        });
extern const auto gemm_copy_register_inst_lauum =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, Triangular>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto S) -> const void * {
            constexpr KernelConfig Conf{
                .negate = Negate, .struc_A = transpose(S), .struc_B = S, .struc_C = S};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_lauum_trans =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, Triangular>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto S) -> const void * {
            constexpr KernelConfig Conf{
                .negate = Negate, .struc_A = S, .struc_B = transpose(S), .struc_C = S};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });
extern const auto gemm_copy_register_inst_trtrsyrk_sC =
    guanaqo::make_lut<ColRowMajor, ColRowMajor, ColRowMajor, 2, 2>(
        []<auto OA, auto OB, auto OC>(CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>,
                                      auto S, auto M) -> const void * {
            constexpr int sC     = S ? 1 : -1;
            constexpr auto struc = MatrixStructure::LowerTriangular;
            constexpr KernelConfig Conf{.negate   = Negate,
                                        .rotate_C = sC,
                                        .rotate_D = sC,
                                        .mask_D   = M ? sC : 0,
                                        .struc_A  = transpose(struc),
                                        .struc_B  = struc,
                                        .struc_C  = struc};
            return &wrap<gemm_copy_register<DType, Abi, Conf, OA, OB, OC, OC>>;
        });

} // namespace batmat::linalg::micro_kernels::gemm
