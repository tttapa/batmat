#ifdef __clang__
#pragma clang fp contract(fast)
#endif

#include <batmat/linalg/micro-kernels/gemm-diag.tpp>

// clang-format off
namespace batmat::linalg::micro_kernels::gemm_diag::@DType@_@VL@_@Negate@ {
using DType = @DType@;
using Abi   = datapar::deduced_abi<DType, @VL@>;
static constexpr bool Negate = @Negate@;
// clang-format on

using enum StorageOrder;
using enum MatrixStructure;

template <StorageOrder O>
using CStorageOrder = std::integral_constant<StorageOrder, O>;
template <MatrixStructure O>
using CMatrixStructure = std::integral_constant<MatrixStructure, O>;

constexpr std::array FalseTrue{false, true};
constexpr std::array ColRowMajor{ColMajor, RowMajor};
constexpr std::array Triangular{LowerTriangular, UpperTriangular};

namespace {
template <auto V>
const auto wrap = V;
} // namespace

extern const auto gemm_diag_copy_register_inst_gemm =
    guanaqo::make_lut<FalseTrue, ColRowMajor, ColRowMajor, ColRowMajor, ColRowMajor>(
        []<auto OA, auto OB, auto OC, auto OD>(auto tz, CStorageOrder<OA>, CStorageOrder<OB>,
                                               CStorageOrder<OC>,
                                               CStorageOrder<OD>) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate, .track_zeros = tz};
            return &wrap<gemm_diag_copy_register<DType, Abi, Conf, OA, OB, OC, OD>>;
        });
extern const auto gemm_diag_copy_register_inst_syrk =
    guanaqo::make_lut<FalseTrue, ColRowMajor, ColRowMajor, ColRowMajor, ColRowMajor, Triangular>(
        []<auto OA, auto OB, auto OC, auto OD, auto SC>(
            auto tz, CStorageOrder<OA>, CStorageOrder<OB>, CStorageOrder<OC>, CStorageOrder<OD>,
            CMatrixStructure<SC>) -> const void * {
            constexpr KernelConfig Conf{.negate = Negate, .track_zeros = tz, .struc_C = SC};
            return &wrap<gemm_diag_copy_register<DType, Abi, Conf, OA, OB, OC, OD>>;
        });

} // namespace batmat::linalg::micro_kernels::gemm_diag
