#pragma once

#include <koqkatoo/cholundate/householder-downdate.hpp>
#include <koqkatoo/lut.hpp>
#include "micro-kernels/householder-downdate.hpp"

namespace koqkatoo::cholundate::householder {

namespace detail {
using micro_kernels::matrix_accessor;
using micro_kernels::mut_matrix_accessor;
using micro_kernels::householder::Config;
using micro_kernels::householder::mut_W_accessor;
/// Greedily partitions the given size S into multiples of M and Ms, and calls
/// `downdate_tail<{R, M}>` for these sizes. Practically, M and Ms should
/// be the sizes of the available instantiations of @ref downdate_tail, in
/// descending order.
/// For example, `tile_tail<{4, 8}, 15, 8, 4, 2, 1>` will call
/// `downdate_tail<4, 8>` on the first block row of its arguments, then
/// `downdate_tail<4, 4>` on the second block row, `downdate_tail<4, 2>`
/// and finally `downdate_tail<4, 1>` for the bottom row.
template <Config Conf, index_t S, index_t M, index_t... Ms>
void tile_tail(mut_matrix_accessor L, matrix_accessor B, mut_matrix_accessor A,
               index_t colsA, mut_W_accessor<Conf.block_size_r> W) {
    using micro_kernels::householder::downdate_tail;
    constexpr auto simd_M = micro_kernels::native_simd_size;
    // If the block size is larger than the config allows, skip it.
    constexpr bool skip_large_M = M > Conf.block_size_s || M > S;
    // If the block size is not efficiently vectorizable, and is not yet a
    // remainder block size smaller than the vector length, skip it.
    // E.g. on AVX2, S=12, Ms={12, 8, 4, 2, 1} should use the kernel of size 12,
    // which will use 3 vector registers of size 4 internally, but on AVX512,
    // it should first use the kernel of size 8, and then 4.
    constexpr bool skip_suboptimal_M = M > simd_M && (M % simd_M) != 0;
    if constexpr (S == 0) {
        return;
    } else if constexpr (skip_large_M || skip_suboptimal_M) {
        return tile_tail<Conf, S, Ms...>(L, B, A, colsA, W);
    } else {
        constexpr Config NewConf{.block_size_r = Conf.block_size_r,
                                 .block_size_s = M};
        downdate_tail<NewConf>(L, B, A, colsA, W);
        return tile_tail<Conf, S - M, M, Ms...>(L.middle_rows(M), B,
                                                A.middle_rows(M), colsA, W);
    }
}
} // namespace detail

/// @see @ref detail::tile_tail
/// The sizes specified here should be instantiated in the code generated by
/// CMake.
template <micro_kernels::householder::Config Conf, index_t S>
constexpr auto tile_tail =
    detail::tile_tail<Conf, S, 64, 48, 40, 32, 24, 16, 12, 8, 4, 2, 1>;

inline namespace serial {

template <Config Conf>
void downdate_blocked(MutableRealMatrixView L, MutableRealMatrixView A) {
    using micro_kernels::householder::downdate_diag;
    using micro_kernels::householder::downdate_full;
    using micro_kernels::householder::downdate_tail;

    constexpr index_t R = Conf.block_size_r, S = Conf.block_size_s;
    constexpr micro_kernels::householder::Config uConf{.block_size_r = R,
                                                       .block_size_s = S};
    static_assert(Conf.num_blocks_r == 1 && Conf.num_blocks_s == 1, "NYI");
    assert(L.rows == L.cols);
    assert(L.rows == A.rows);
    constinit static auto full_microkernel_lut = make_1d_lut<R>(
        []<index_t N>(index_constant<N>) { return downdate_full<N + 1>; });
    constinit static auto downdate_tail_lut = make_1d_lut<S>(
        []<index_t N>(index_constant<N>) { return tile_tail<uConf, N + 1>; });

    // Leaner accessors (without unnecessary dimensions and strides).
    micro_kernels::mut_matrix_accessor L_{L}, A_{A};
    // Workspace storage for W (upper triangular Householder representation)
    micro_kernels::householder::matrix_W_storage<R> W;

    // Optional packing of one block row of A.
    auto A_pack = [&] {
        if constexpr (Conf.enable_packing) {
            index_t num_pack = R * A.cols;
            return std::vector<real_t>(num_pack);
        } else {
            struct Empty {};
            return Empty{};
        }
    }();
    auto pack_Ad = [&](index_t k) -> micro_kernels::mut_matrix_accessor {
        if constexpr (Conf.enable_packing) {
            MutableRealMatrixView Ad{
                {.data = A_pack.data(), .rows = R, .cols = A.cols}};
            Ad = A.middle_rows(k, R);
            return Ad;
        }
        return A.middle_rows(k, R);
    };

    // Process all diagonal blocks in multiples of R (except the last).
    index_t k;
    for (k = 0; k + R < L.rows; k += R) {
        auto Ad = pack_Ad(k);
        auto Ld = L_.block(k, k);
        downdate_diag<R>(Ld, Ad, A.cols, W);
#if 1
        // First process the sub-diagonal blocks in multiples of S.
        index_t i;
        for (i = k + R; i <= L.rows - S; i += S) {
            auto Ls = L_.block(i, k);
            auto As = A_.middle_rows(i);
            downdate_tail<uConf>(Ls, Ad, As, A.cols, W);
        }
        // Then process any remainder smaller than S.
        index_t rem_i = L.rows - i;
        assert(rem_i < S);
        if (rem_i > 0) {
            auto Ls = L_.block(i, k);
            auto As = A_.middle_rows(i);
            downdate_tail_lut[rem_i - 1](Ls, Ad, As, A.cols, W);
        }
#else
        for (index_t ii = kk + R; ii < L.rows; ii += S) {
            index_t ni = std::min<index_t>(L.rows, ii + S) - ii;
            auto Ls    = L_.block(ii, kk);
            auto As    = A_.middle_rows(ii);
            downdate_tail_lut[ni - 1](Ls, Ad, As, A.cols, W);
        }
#endif
        // TODO: Could it be beneficial to traverse all even columns from top to
        //       bottom, and the odd columns from bottom to top?
    }
    index_t rem_k = L.rows - k;
    assert(rem_k <= R);
    auto Ad = A_.middle_rows(k); // TODO: pack?
    auto Ld = L_.block(k, k);
    full_microkernel_lut[rem_k - 1](Ld, Ad, A.cols);
}

} // namespace serial

} // namespace koqkatoo::cholundate::householder